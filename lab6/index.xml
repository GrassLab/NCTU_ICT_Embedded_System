<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>實驗六，核心空間GPIO裝置驅動程式 on 國立交通大學, 嵌入式作業系統設計與實作</title>
    <link>/NCTU_ICT_Embedded_System/lab6/</link>
    <description>Recent content in 實驗六，核心空間GPIO裝置驅動程式 on 國立交通大學, 嵌入式作業系統設計與實作</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 05 Oct 2020 03:48:21 +0000</lastBuildDate><atom:link href="/NCTU_ICT_Embedded_System/lab6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux核心模組</title>
      <link>/NCTU_ICT_Embedded_System/lab6/step1/</link>
      <pubDate>Mon, 05 Oct 2020 13:41:02 +0000</pubDate>
      
      <guid>/NCTU_ICT_Embedded_System/lab6/step1/</guid>
      <description>Linux提供動態載入移除核心模組的功能，使得記憶體不會被沒有使用到的模組佔據。 大部分的驅動程式都是透過Linux核心模組在開機時或開機後動態載入核心空間中。
這個章節會教導如何寫和編譯最基礎的核心模組，使同學了解在核心空間的程式是如何運行的。
編譯核心模組 下載Linux核心標頭檔 這次實驗會直接在樹莓派上面進行編譯核心模組的工作，因此要先下載對應的標頭檔。 不同的Linux核心版本使用的標頭檔可能會不一樣，而Raspberry Pi OS (32-bit)使用的版本可以透過以下指令下載。
sudo apt install raspberrypi-kernel-headers 核心模組基礎程式碼 Linux的核心模組需要透過module_init和module_exit註冊載入時的初始函式和移除時的卸載函式。
而核心模組一般而言要透過MODULE_LICENSE指定使用的軟體授權條款， 而Linux核心本身是GPL條款。 在載入核心模組時會檢查該模組的條款，如果使用的條款不是GPL相容的條款，將會無法呼叫部分Linux核心提供的函式。
以上用到的Macro可以藉由&amp;lt;linux/module.h&amp;gt;引入。
#include &amp;lt;linux/module.h&amp;gt; MODULE_LICENSE(&amp;#34;GPL&amp;#34;); int mymodule_init(void) { printk(&amp;#34;My Module INIT\n&amp;#34;); return 0; } void mymodule_exit(void) { printk(&amp;#34;My Module EXIT\n&amp;#34;); } module_init(mymodule_init); module_exit(mymodule_exit); 核心模組Makefile Linux核心模組在編譯過程涉及許多步驟，編譯時也要加上許多編譯選項。 可以透過make -C指定Linux核心所在目錄，並使用其提供的Makefile。
在核心模組的Makefile需要透過obj-m標明要編譯的模組，該模組所需要用到的原始碼可以用*-objs 來指定。 接下來透過M=...指定模組原始碼的路徑後，將編譯目標設為modules即可編譯出*.ko模組。
clean可以清除編譯產生的檔案
obj-m += mymodule.o mymodule-objs := main.o modules: make -C /lib/modules/${shell uname -r}/build M=${PWD} modules clean: make -C /lib/modules/${shell uname -r}/build M=${PWD} clean 編譯上述範例 mkdir lab6 cd lab6 # create main.</description>
    </item>
    
    <item>
      <title>平台裝置/驅動程式</title>
      <link>/NCTU_ICT_Embedded_System/lab6/step2/</link>
      <pubDate>Mon, 05 Oct 2020 14:58:35 +0000</pubDate>
      
      <guid>/NCTU_ICT_Embedded_System/lab6/step2/</guid>
      <description>所有的周邊裝置都是藉由匯流排來連接， 某些裝置在在載入時可以主動通知Linux核心，此時Linux核心可以載入對應的驅動程式。 然而在嵌入式系統中，大部分的裝置都無法透過像這樣的方式讓Linux核心枚舉出現在載入的裝置。
這種無法主動被Linux核心發現的裝置稱為平台裝置， 平台裝置通常是透過實驗五提過的裝置樹在開機時載入，而Linux核心提供了平台裝置驅動程式的框架來統一並加速相關驅動程式的開發。
平台驅動程式範例 #include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/of.h&amp;gt; #include &amp;lt;linux/platform_device.h&amp;gt; MODULE_LICENSE(&amp;quot;GPL&amp;quot;); struct of_device_id mymodule_dt[] = { { .compatible = &amp;quot;mymodule&amp;quot;, }, {}, }; int mymodule_probe(struct platform_device *pdev) { printk(&amp;quot;mymodule PROBE\n&amp;quot;); return 0; } int mymodule_remove(struct platform_device *pdev) { printk(&amp;quot;mymodule REMOVE\n&amp;quot;); return 0; } struct platform_driver mymodule = { .probe = mymodule_probe, .remove = mymodule_remove, .driver = { .name = &amp;quot;mymodule&amp;quot;, .of_match_table = of_match_ptr(mymodule_dt), .owner = THIS_MODULE, }, }; module_platform_driver(mymodule); 和前面介紹過的核心模組不同，這這份程式碼中並沒有看到module_init和module_exit，取而代之的是probe和remove函式。 但是如果往下追蹤module_platform_driver這個註冊平台驅動程式的Macro會發現module_init和module_exit是被包裝在裡面的。</description>
    </item>
    
    <item>
      <title>GPIO的中斷與sysfs</title>
      <link>/NCTU_ICT_Embedded_System/lab6/step3/</link>
      <pubDate>Tue, 06 Oct 2020 07:31:19 +0000</pubDate>
      
      <guid>/NCTU_ICT_Embedded_System/lab6/step3/</guid>
      <description>在前面章節在前面章節簡單的介紹了平台裝置，以及如何透過Linux本身GPIO函式庫進行GPIO操作。 這個章節會介紹如果透過中斷來降低按鈕電位改變至LED的電位連帶改變的延遲。 並且介紹如何將mydevice註冊到sysfs
中斷 CPU可以接收來自周邊裝置的硬體中斷，並在接收到中斷時才存取周邊裝置的資料。 如此一來驅動程式不需要透過輪詢持續的存取周邊裝置。
透過Linux核心GPIO函式庫中的gpiod_to_irq可以直接拿到一個中斷號碼，中斷號碼可以再透過request_irq來註冊中斷處理函式。
在註冊中斷處理函式時可以指定中斷的觸發方式，藉此可以達到按下按鈕和放開時都觸發該函式達到開關LED的效果。
#include &amp;lt;linux/gpio/consumer.h&amp;gt;#include &amp;lt;linux/interrupt.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/of.h&amp;gt;#include &amp;lt;linux/platform_device.h&amp;gt; MODULE_LICENSE(&amp;#34;GPL&amp;#34;); struct of_device_id mymodule_dt[] = { { .compatible = &amp;#34;mymodule&amp;#34;, }, {}, }; int irq; struct gpio_desc* led; struct gpio_desc* btn; irqreturn_t btn_irq_handler(int irq, void* dev) { int state = gpiod_get_value(btn); gpiod_set_value(led, state); return IRQ_HANDLED; } int mymodule_probe(struct platform_device* pdev) { struct device* dev = &amp;amp;pdev-&amp;gt;dev; int retVal; led = gpiod_get_index(dev, &amp;#34;led&amp;#34;, 0, GPIOD_OUT_LOW); btn = gpiod_get_index(dev, &amp;#34;btn&amp;#34;, 0, GPIOD_IN); irq = gpiod_to_irq(btn); retVal = request_irq(irq, btn_irq_handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, &amp;#34;btn_irq_handler&amp;#34;, NULL); printk(&amp;#34;mymodule PROBE, requested irq %d, succeed?</description>
    </item>
    
    <item>
      <title>Demo</title>
      <link>/NCTU_ICT_Embedded_System/lab6/step4/</link>
      <pubDate>Tue, 06 Oct 2020 07:31:19 +0000</pubDate>
      
      <guid>/NCTU_ICT_Embedded_System/lab6/step4/</guid>
      <description>Demo 實做平台裝置驅動程式，使其可以透過按鈕來開關LED燈
該驅動程式必須完成以下功能
 在sysfs下新增裝置屬性method和time，使用者可以透過寫入裝置屬性來控制按鈕開關LED的方式，並可以透過讀取裝置屬性來得知當前開關之設定  method的可能值有press_time和press_count兩種，預設為press_time。 time的可能值為大於等於1的整數。 如果使用者輸入非法數值，則維持先前數值   在method為press_time的情況下，請實做以下功能  以中斷的方式得知按鈕持續按壓的時間 若按壓時間超過time設置的時間，則將LED切換為打開/關閉 time的單位可以為秒或者毫秒   在method為press_count的情況下，請實做以下功能  以kthread的方式監控按鈕連擊的次數 若連擊次數剛好等於time，則將LED切換為打開/關閉    同學可以使用jiffies_to_msecs(jiffies)來計算經過的時間
完成TODO的部分(bonus不必要)，可以再之後進行補Demo並獲得3分 然而由於TODO是用填空的方式，如果還是有不知道要填什麼的部分，請於之後課後詢問。
#include &amp;lt;linux/delay.h&amp;gt;#include &amp;lt;linux/gpio/consumer.h&amp;gt;#include &amp;lt;linux/interrupt.h&amp;gt;#include &amp;lt;linux/kthread.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/of.h&amp;gt;#include &amp;lt;linux/platform_device.h&amp;gt;#include &amp;lt;linux/sysfs.h&amp;gt; MODULE_LICENSE(&amp;#34;GPL&amp;#34;); struct of_device_id mymodule_dt[] = { { .compatible = &amp;#34;mymodule&amp;#34;, }, {}, }; struct task_struct *count_thread; struct task_struct *count_bonus_thread; int irq; // shared variables between each methods struct gpio_desc *led; struct gpio_desc *btn; int led_state = 0; unsigned int time = 1; // methods enum { PRESS_TIME, PRESS_COUNT, PRESS_COUNT_BONUS, }; size_t current_method = PRESS_TIME; const char *methods[] = { [PRESS_TIME] = &amp;#34;press_time&amp;#34;, [PRESS_COUNT] = &amp;#34;press_count&amp;#34;, [PRESS_COUNT_BONUS] = &amp;#34;press_count_bonus&amp;#34;, }; // kthread: press_count_bonus int press_count_bonusd(void *arg) { // NOTE: You don&amp;#39;t have to do the bonus.</description>
    </item>
    
  </channel>
</rss>
